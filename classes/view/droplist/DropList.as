// Define the Packagepackage classes.view.droplist {		// Import Necessary Classes	import flash.text.TextField;	import flash.events.MouseEvent;	import flash.display.Sprite;	import flash.utils.setInterval;	import flash.utils.clearInterval;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.utils.setTimeout;	import flash.display.DisplayObject;		// Define the Class	public final class DropList extends Sprite {				// Save a Reference to List Options		private var vls:Array = [ 'Option Aaaa', 'Option Aaab', 'Option Aaac', 'Option Aabb', 'Option Aabc', 'Option Abbb', 'Option Abbc', 'Option Abcc', 'Option Accc', 'Option Bbbb', 'Option Bbbc', 'Option Bbcc', 'Option Bccc', 'Option Cccc', 'Option Dddd', 'Option Ddde', 'Option Dddf', 'Option Ddee', 'Option Ddef', 'Option Ddff', 'Option Deee', 'Option Deef', 'Option Deff', 'Option Dfff', 'Option Eeee', 'Option Eeef', 'Option Eeff', 'Option Efff', 'Option Ffff' ];		// Create a Variable for Input and Hint TextFields		private var npt:Vector.<TextField>;		// Create a Variable for List Option TextFields		private var opt:Vector.<TextField>;		// Create a Variable for Scroll Arrow Buttons		private var arw:Vector.<Sprite>;		// Create a Variable for Background Sprites		private var bgs:Vector.<Sprite>;		// Create a Variable for Hilighted List Option TextField		private var hig:TextField;		// Save a Refernece to Input TextField Text		private var txt:String = '';		// Create a Variable for the Search Patern		private var reg:RegExp;		// Save a Reference to the Scroll Position		private var scr:int;		// Create a Variable for Delayed Function Calls		private var tme:int;		// Create a Variable for the Number of Visible List Options		private var rws:int;		// Create a Variable for the Number of Filtered List Options		private var len:int;		// Create a Variable for the Selected List Option		private var sel:int;		// Create a Variable for the List Option TextField Offset		private var off:int;				// Instantiate the Class		public function DropList ( obj:Object ) : void {			// Save a Refernece to List Option TextFields			opt = new <TextField> [ list_mc.fld0, list_mc.fld1, list_mc.fld2, list_mc.fld3, list_mc.fld4, list_mc.fld5, list_mc.fld6, list_mc.fld7, list_mc.fld8, list_mc.fld9, list_mc.fld10, list_mc.fld11, list_mc.fld12, list_mc.fld13, list_mc.fld14, list_mc.fld15, list_mc.fld16, list_mc.fld17, list_mc.fld18, list_mc.fld19, list_mc.fld20, list_mc.fld21, list_mc.fld22, list_mc.fld23 ];			// Save a Refernece to Scroll Arrow Buttons			arw = new <Sprite> [ list_mc.up_btn, list_mc.down_btn ];			// Save a Reference to Background Sprites			bgs = new <Sprite> [ input_bg, list_mc.list_bg ];			// Save a Reference to Input and Hint TextFields			npt = new <TextField> [ input_fld, hint_fld ];			// Save a Reference to the List Option Values			vls = obj.list as Array || vls;			// Lock Vectors for Iteration Optimisation			opt.fixed = arw.fixed = bgs.fixed = npt.fixed = true;			// Save a Reference to the Selected Index			sel = obj.value || 0;			// Save a Reference to the Object Width			var wid:Number = obj.width || 195;			// Dsiplay the Label TextField Text			label_fld.htmlText = '<b>' + ( obj.label && obj.label + '       ' || '' );			// Dsiplay the Default Input TextField Text			input_fld.text = vls [ sel ] || input_fld.text;			// Position the Input and Hint TextFields			input_fld.x = hint_fld.x += label_fld.textWidth;			// Set the X Position			x = obj.x || x;			// Set the Y Position			y = obj.y || y;			// Set the Width of the Input TextField Background			input_bg.width = wid;			// Set the Width of the List Option TextFields			for each ( var np:TextField in npt ) np.width = wid - 48 - label_fld.textWidth;			// Set the Width of the Input TextField Background			list_mc.list_bg.width = wid += 3;			// Loop through the Scroll Arrow Buttons			for each ( var btn:Object in arw ) {				// Set the Width of the Scroll Arrow Buttons				btn.arrow_mc.x = ( wid - 14 ) * .5;				// Vertically Align the Arrows				btn.getChildAt ( 0 ).width = wid - 14;				// Prevent Errant Events				btn.mouseChildren = false;			}			// Set the Width of the List Option TextFields			for each ( var fld:TextField in opt ) fld.width = wid - 14;			// Save a Reference to the Number of Filtered List Options			len = vls.length;			// Save a Reference to the Number of Visible List Options			rws = max ( 0,  min ( opt.length - 1, min ( len, ( 800 - y - 59 ) / 30 ) ) );			// Set the Height of the List Background			bgs [ 1 ].height = rws * 30 + 14;			// Set the Position of the Bottom Scroll Arrow			arw [ 1 ].y = opt [ rws ].y			// Listen for Mouse Over Events			addEventListener ( MouseEvent.MOUSE_OVER, on_over, false, 0, true );			// Listen for Mouse Out Events			addEventListener ( MouseEvent.MOUSE_OUT, on_out, false, 0, true );			// Listen for Click Events			addEventListener ( MouseEvent.CLICK, on_click, false, 0, true );			// Listen for Change Events			addEventListener ( Event.CHANGE, on_change, false, 0, true );			// Listen for Added to Stage Event			addEventListener ( Event.ADDED_TO_STAGE, on_added, false, 0, true );			// React to Change Events			on_change ( null );		}				// React to Added to Stage Event		function on_added ( evt:Event ) : void {			// Listen for KeyDown Events			stage.addEventListener ( KeyboardEvent.KEY_DOWN, on_key, false, 0, true );			// Listen for Mouse Down Events			stage.addEventListener ( MouseEvent.MOUSE_DOWN, on_down, false, 0, true );			// Focus on the Input Field			stage.focus = input_fld;			// Select the Input Field Text			input_fld.setSelection ( 9999, 9999 );		}				// React to Change Events		private function on_change ( evt ) : void {			// Save a Reference to the Input Field Text			var _txt:String = input_fld.text, _vls:Array = vls;			// Save a Refernece to the Search Patern			var _reg:RegExp = new RegExp ( '^' + _txt.replace ( /(\W)/gi, '\\$1' ), 'i' );			// Loop through the All List Option Values			for ( var n:int = 0, ndx:int = -1, i:int = _vls.length; i--; n++ ) {				// Check that the Values Match the Search Pattern				if ( !_reg.test (  _vls [ n ] ) ) continue;				// Save a Reference to the Matching List Option Value Index				ndx = n;				// Stop Looping				break;			}			// Check that No Matching List Option Value was Found			if ( ndx < 0 ) {				// Reset the Input Field TextField Text				input_fld.text = txt;				// Do Nothing Further				return;			}			// Save a Referenece to the Input Field TextField Text			txt = _txt;			// Save a Refernece to the Search Patern			reg = _reg;			// Scroll to the Appropriate List Option			do_scroll ( ndx - scr, false );			// Simulate a Mouse Over of the Appropriate List Option TextField			on_over ( { target: opt [ ndx - off ] } );		}				// React to KeyDown Events		private function on_key ( evt:KeyboardEvent ) : void {			// Save a Reference to the KeyCode			var cde:int = evt.keyCode;			// Scroll Downwards on Down Arrow Key Press			if ( cde === 40 ) do_hilight ( 1 );			// Scroll Upwards on Up Arrow Key Press			else if ( cde === 38 ) do_hilight ( -1 );			// Autofil Input TextField on Right Arrow Key Press			else if ( cde === 39 && input_fld.caretIndex === input_fld.length ) do_selection ( );			// Autofil Input TextField on Enter Key Press			else if ( cde === 13 ) do_selection ( true );			// Do Nothing Further if Other Keys Were Pressed			else return;			// Prevent Event Default Behavior			evt.preventDefault ( );		}				// React to Mouse Over Events		private function on_over ( evt:Object ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Check that the Event Target is a List Option TextField			if ( opt.indexOf ( tar ) + 1 ) {				// Unhilight Previously Hilighted List Option TextField				if ( hig ) hig.opaqueBackground = null;				// Hilight the Currnet List Option TextField				tar.opaqueBackground = 0xEFEFEF;				// Save a Refernec to the Currnetly Hilighted List Option TextField				hig = tar as TextField;				// Save a Reference to the Input Field TextField Text				var _txt:String = txt;				// Save a Reference to the Target List Option TextField Text				var str:String = tar.text.substr ( 1 );				// Display the Appropriate Hint				if ( reg.test ( str ) ) hint_fld.htmlText = '<font color="#FFFFFF">' + _txt + '</font>' + str.substr ( _txt.length );			}			// Hilight the Scroll Arrow Button			if ( arw.indexOf ( tar ) + 1 )  tar.arrow_mc.alpha = .75;			// Scroll the List Options Upwards			if ( tar.name === 'down_btn' ) do_scroll ( 1 );			// Scroll the List Options Downwards			if ( tar.name === 'up_btn' ) do_scroll ( -1 );			// Rerender After the Event			if ( evt.updateAfterEvent ) evt.updateAfterEvent ( );		}				// React to Mouse Out Events		private function on_out ( evt:Object ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Rerender After the Event			if ( evt.updateAfterEvent ) evt.updateAfterEvent ( );			// Check that the Event Target is a Scroll Arrow Button			if ( arw.indexOf ( tar ) + 1 ) {				// Unhighlight the Scroll Arrow Button				tar.arrow_mc.alpha = 1;				// Clear Any Delayed Function Calls				clearInterval ( tme );			}		}				// React to Click Events		private function on_click ( evt:MouseEvent ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Do Nothing If the Target Is Not a List Option TextField			if ( opt.indexOf ( tar ) === -1 ) return;			// Autofill Input TextField			do_selection ( true );			// Rerender After the Event			evt.updateAfterEvent ( );		}				// React to Mouse Down Events		private function on_down ( evt:Object ) : void {			// Save a Refernece to the Target			var tar:DisplayObject = evt.target as DisplayObject;			// Do Nothing If We Still Have Focus			if ( tar === this || contains ( tar ) ) return;			// Stop Listening for Mouse Down Events			stage.removeEventListener ( MouseEvent.MOUSE_DOWN, on_down );			// Remove Us From the Stage			parent.removeChild ( this );			// Dispatch an Event			dispatchEvent ( new DropListEvent ( { type:'done', value:sel } ) );			// Rerender After the Event			if ( evt.updateAfterEvent ) evt.updateAfterEvent ( );		}				// Autofill Input TextField		private function do_selection ( end:Boolean = false ) : void {			// Save a Reference to the Selected List Option Value Index			sel = opt.indexOf ( hig ) + off;			// Update the Input TextField Text			input_fld.text = txt = vls [ sel ];			// Move the Input TextField Caret to the End			input_fld.setSelection ( 9999, 9999 );			// Simulate a Stage Click Event			if ( end ) on_down ( { target:stage } );		}				// Increment/Decrement the Hilighted List Option TextField		private function do_hilight ( dir:int = 0 ) : void {			// Determine the List Option TextField Index			var ndx:int = opt.indexOf ( hig ) + dir;			// Check that The List Should Scroll Upwards			if ( ndx === 0 && arw [ 0 ].visible ) {				// Scroll the List Upwards				do_scroll ( -1, false );				// Hilight the Appropriate List Option TextField				on_over ( { target: opt [ 1 ] } );			}			// Check that The List Should Scroll Dowmwards			else if ( ndx === rws - 1 && arw [ 1 ].visible ) {				// Scroll the List Dowmwards				do_scroll ( 1, false );				// Hilight the Appropriate List Option TextField				on_over ( { target: opt [ rws - 2 ] } );			}			// Hilight the Appropriate List Option TextField			else on_over ( { target: opt [ min ( rws - 1, max ( 0, ndx ) ) ] } );		}				// Scroll the List Upwards or Downwards		private function do_scroll ( dir:int = 0, rec:Boolean = true ) : void {			// Display the Appropriate List Options			do_options ( scr = min ( len - rws, max ( 0, scr + dir ) ) );			// Clear Any Delayed Function Calls			clearInterval ( tme );			// Scroll the List Again after a Delay			if ( rec ) tme = setTimeout ( do_scroll, 100, dir );		}				// Display the Appropriate List Options		private function do_options ( min:int = 0 ) : void {			// Create Local References to Global Variables			var _rws:int = rws, _len:int = len, _vls:Array = vls, _opt:Vector.<TextField> = opt, _arw:Vector.<Sprite> = arw;			// Save a Refernece to the Starting Index			var i:int = off = min < 0 ? 0 : min >= _len - rws ? _len - _rws : min > 0 ? min - 1 : 0;			// Display/Hide the Up Scroll Arrow Button			_arw [ 0 ].visible = min > 0;			// Display/Hide the Down Scroll Arrow Button			_arw [ 1 ].visible = min + _rws < _len - 1;			// Loop through the List Option TextFields			for ( var n:int = _opt.length, m:int = 0; n--; ) {				// Save a Refernece to the Current List Option TextField				var fld:TextField = _opt [ m++ ];				// Display/Hide the List Option TextField				if ( !( fld.visible = m <= _rws ) ) continue;				// Display the Appropriate List Option Text				fld.text = '\n' + _vls [ i++ ];			}		}				// Calculate Math.min But Faster		private function min ( a:Number, b:Number ) : Number { return a < b ? a : b }				// Calculate Math.max But Faster		private function max ( a:Number, b:Number ) : Number { return a > b ? a : b }	}}