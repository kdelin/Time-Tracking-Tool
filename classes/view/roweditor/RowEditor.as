 // Define the Packagepackage classes.view.roweditor {		// Import Necessary Classes	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.globalization.DateTimeFormatter;	import flash.globalization.LocaleID;	import flash.text.TextField;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.filters.DropShadowFilter;			import classes.view.roweditor.RowEditorEvent;		import classes.view.suggestionfield.SuggestionField;	import classes.view.datepicker.DatePicker;	import classes.view.timefield.TimeField;	import classes.view.droplist.DropList;			// Define the Class	public final class RowEditor extends Sprite {				// Save a Reference to a DropShadowFilter for Hilighting		private var sdw:DropShadowFilter = new DropShadowFilter ( 2, 89.9993809572637, 0, 1, 6, 6, 0.5, 3, false, false, false );		// Create DateTimeFormatter Object for Date Time Format		private var dte:DateTimeFormatter = new DateTimeFormatter ( LocaleID.DEFAULT );		// Create a Variable for Field Inputs		private var npt:Vector.<TextField>;		// Create a Variable for Field Labels		private var lbl:Vector.<TextField>;		// Create a Variable for Field Sprites		private var fld:Vector.<Sprite>;		// Create a Variable for Field Picklists		private var lst:Array = [ ];		// Create a Variable for Field Picklists		private var opt:Array = [ ];		// Create array for formats		private var arr:Array = [ ];		// Create array for values		private var vls:Array = [ ];		// Create array for labels		private var lbs:Array = [ ];		// Create a Variable for Field Types		private var typ:Vector.<Function> = new <Function> [ ];		// keep track of which field is clicked		private var f:int = 0;		// create temp objects for edit fields		private var sf:SuggestionField;		private var dl:DropList;		private var dp:DatePicker;		private var tf:TimeField;		// create var that manages one field at a time		private var allowEdit:Boolean = true;						// Instantiate the Class		public function RowEditor ( obj:Object ) : void {			// Setup Date Time Format Pattern			dte.setDateTimePattern ( 'MM/dd/yy h:00 a z' );			// Save a Reference to All Field Sprites			fld = new <Sprite> [ input1_mc, input2_mc, input3_mc, input4_mc, input5_mc, input6_mc, input7_mc, input8_mc, input9_mc ];			// Save a Reference to All Field Inputs			npt = new <TextField> [ input1_mc.input_fld, input2_mc.input_fld, input3_mc.input_fld, input4_mc.input_fld, input5_mc.input_fld, input6_mc.input_fld, input7_mc.input_fld, input8_mc.input_fld, input9_mc.input_fld ];			// Save a Reference to All Field Labels			lbl = new <TextField> [ input1_mc.label_fld, input2_mc.label_fld, input3_mc.label_fld, input4_mc.label_fld, input5_mc.label_fld, input6_mc.label_fld, input7_mc.label_fld, input8_mc.label_fld, input9_mc.label_fld ];			// Save a Reference to Field Picklist Label			lst = obj.lists as Array || [ ]; lst.reverse();			// Save a Reference to the Field Picklist Options			for ( var n:int = lst.length; n--; ) { opt[ n ] = lst [ n ]; }; opt.reverse();			// Save a Reference to All Field Types			arr = obj.formats as Array || [ ];			// Make Functions for Formating Data			for ( n = typ.length = arr.length; n--; ) typ [ n ] = do_type ( arr [ n ] );			// Lock Vecors for Optimized Iteration			fld.fixed = npt.fixed = lbl.fixed = typ.fixed = true;			// Save a Reference to the Labels			lbs = obj.labels as Array || [ ];			// Save a Reference to the Values			vls = obj.values as Array || [ ];			//  Save a Referece to the Maximum Number of Fields			var max:int =  min ( fld.length - 1, lbs.length );			// Position the Lower Hirizontal Line			line_mc.y = fld [ max - 1 ].y + 60;			// Position the Close Button			close_btn.y = line_mc.y + 20;			// Set the Background Height			bg_mc.height = close_btn.y + 55;			// Set the Y Position			x = ( 800 - width ) * .5;			// Set the Y Position			y = ( 800 - height ) * .5;						// Loop through the Fields			for ( n = fld.length; n--; ) {				// Check that There's No Data for the Field				if ( !( fld [ n ].visible = n < max ) ) continue;				// Display the Appropriate Label				lbl [ n ].htmlText = '<b>' +  ( lbs [ n ] || '' ) + '          ';				// Display the Appropriate Value				npt [ n ].text = typ [ n ] ( vls [ n ] );				// Position the Field Input Appropriately				npt [ n ].x += lbl [ n ].textWidth;				// Set the Field Input Width				npt [ n ].width -= lbl [ n ].textWidth;				// Prevent Errant Mouse Events				fld [ n ].mouseChildren = false;								// Set up each field as a button				fld [ n ].buttonMode = true;				// Add roll over effect								fld [ n ].addEventListener(MouseEvent.MOUSE_OVER, overHandler);				fld [ n ].addEventListener(MouseEvent.MOUSE_OUT, outHandler);							}			// Listen for Added to Stage Event			addEventListener ( Event.ADDED_TO_STAGE, on_added );		}				// React to Added to Stage Event		private function on_added ( evt:Event ) : void {						// Listen for Mouse Down Event			stage.addEventListener ( MouseEvent.MOUSE_DOWN, on_down, false, 0, true );		}				// Functions for handling the closing of edit fields				private function on_SuggestionClosed(e:Object):void {			vls[f] = e.value;			npt[f].text = e.value;			sf.removeEventListener("done", on_SuggestionClosed);			allowEdit = true;		}				private function on_ADropListClosed(e:Object):void {			vls[f] = e.value;			npt[f].text = opt[1][e.value];			dl.removeEventListener("done", on_ADropListClosed);			allowEdit = true;		}				private function on_DDropListClosed(e:Object):void {			vls[f] = e.value;			npt[f].text = opt[0][e.value];			dl.removeEventListener("done", on_DDropListClosed);			allowEdit = true;		}				private function on_DatePickerClosed(e:Object):void {			allowEdit = true;			vls[f] = e.value;			npt[f].text = dte.format ( new Date ( e.value ));			dp.removeEventListener("done", on_DatePickerClosed);					}				private function on_TimeFieldClosed(e:Object):void {						allowEdit = true;						vls[f] = Number(e.value);						var st:String = String(e.value);			var str:Array = st.split(".");			var h:String = str[0]; var m:String = str[1];						if ( m == "5" ) m = "30";			if ( m == "" || m == null ) m = "00";						npt[f].text = h + ":" + m;									tf.removeEventListener("done", on_TimeFieldClosed);		}						// React to Mouse Down Event		private function on_down ( evt:MouseEvent ) : void {			// Save a Reference to the Event Target			var tar:DisplayObject = evt.target as DisplayObject;						// If close button, close editor, else handle field			if ( tar === close_btn || !contains ( tar ) ) {				closeRowEditor();			} else if ( allowEdit ) {				editField(evt.target);						}		}				private function closeRowEditor():void {			dispatchEvent ( new RowEditorEvent ( { type:'done', values:vls } ) );			parent.removeChild(this);		}				// handle field button				private function editField( mc:Object ):void {						for ( var n:int = fld.length; n--; ) if ( mc.name == fld[n].name ) break;												if ( arr[n] == "text" ) {				sf = addChild ( new SuggestionField ( { value:vls[n], x:mc.x, y:mc.y, width:mc.width, label:lbs[n], whichField:n } ) ) as SuggestionField;				sf.addEventListener("done", on_SuggestionClosed);				f = n;			} else if ( arr[n] == "picklist" && lbs[n] == "Deliverable" ) {				dl = addChild ( new DropList ( { value:vls[n], x:mc.x, y:mc.y, width:mc.width, label:lbs[n], list:opt[0] })) as DropList;				dl.addEventListener("done", on_DDropListClosed);				f = n;			} else if ( arr[n] == "picklist" && lbs[n] == "Assignee" ) {				dl = addChild ( new DropList ( { value:vls[n], x:mc.x, y:mc.y, width:mc.width, label:lbs[n], list:opt[1] })) as DropList;				dl.addEventListener("done", on_ADropListClosed);				f = n;			} else if ( arr[n] == "date" ) {				dp = addChild ( new DatePicker ( { value:vls[n], x:mc.x, y:mc.y, width:mc.width, label:lbs[n] })) as DatePicker;				dp.addEventListener("done", on_DatePickerClosed);				f = n;			} else if ( arr[n] == "hours" ) {				tf = addChild (new TimeField({ x:mc.x, y:mc.y, width:mc.width, text:vls[n], label:lbs[n] })) as TimeField;				tf.addEventListener("done", on_TimeFieldClosed);				f = n;			}						allowEdit = false;		}				// Make Functions for Formating Data		private function do_type ( typ:String ) : Function {			// Check that the Type is Hours			if ( typ === 'hours' ) {				// Return a Function for Formating Hours				return function ( num:Number ) : String {					// Save a Refernece to the Hours as an Integer					var hrs:int = int ( num );					// Return the Formated Hours and Minutes					return ( ( hrs * .1 ).toFixed ( 1 ) + ':' + ( int ( ( num - hrs ) * 60 ) * .1 ).toFixed ( 1 ) ).replace ( /\./g, '' );				}			}			// Return a Function for Formating Dates			if ( typ === 'date' ) return function ( mil:Number ) : String { return dte.format ( new Date ( mil ) ) };			// Check that the Type is Picklist			if ( typ === 'picklist' ) {				// Save a Reference to the Picklist Options				var als:Array = lst.shift ( ) || [ ];								// Return a Function for Formating Picklists				return function ( ndx:int ) : String { return als [ ndx ] || '' };			}			// Return a Function for Formatiing Text			return function ( val:Object = '' ) : String { return val.toString ( ) };		}				// Calculate Math.min But Faster		private function min ( a:Number, b:Number ) : Number { return a < b ? a : b }				private function overHandler(e:MouseEvent):void {			e.target.alpha = .8;		}				private function outHandler(e:MouseEvent):void {			e.target.alpha = 1;		}			}}