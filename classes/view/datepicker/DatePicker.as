 // Define the Packagepackage classes.view.datepicker {		// Import Necessary Classes	import flash.globalization.DateTimeFormatter;	import flash.globalization.LocaleID;	import flash.events.MouseEvent;	import flash.display.SimpleButton;	import flash.utils.Dictionary;	import flash.text.TextField;	import flash.events.TextEvent;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.events.FocusEvent;	import flash.display.InteractiveObject;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.Point;		// Define the Class	public final class DatePicker extends Sprite {				// Create DateTimeFormatter Object for Date Time Format		var sformat_obj:DateTimeFormatter = new DateTimeFormatter ( LocaleID.DEFAULT );		// Create DateTimeFormatter Object for Month Format		var mformat_obj:DateTimeFormatter = new DateTimeFormatter ( LocaleID.DEFAULT );		// Create DateTimeFormatter Object for Time Format		var tformat_obj:DateTimeFormatter = new DateTimeFormatter ( LocaleID.DEFAULT );		// Create a Dictionary for Dates		var date_dic:Dictionary = new Dictionary ( );		// Create a Variable for Selected Date		var sel_date:Date = new Date ( );		// Create a Variable for Selected Date		var sel_time:Date = new Date ( sel_date.fullYear, sel_date.month, sel_date.date, sel_date.hours, 0, 0 );		// Create a Variable for Target Date		var view_date:Date = new Date ( sel_date.fullYear, sel_date.month, 1, 0, 0, 0, 0 );		// Create a Varianble for the Time TextField		var time_fld:TextField;				// Instantiate the Class		public function DatePicker ( obj:Object ) : void {			// Save a Reference to Selected Date			sel_date = new Date ( obj.value || null );			// Save a Reference to Selected Date			sel_time = new Date ( sel_date.fullYear, sel_date.month, sel_date.date, sel_date.hours, 0, 0 );			// Save a Reference to Target Date			view_date = new Date ( sel_date.fullYear, sel_date.month, 1, 0, 0, 0, 0 );			// Save a Reference to the Time TextField			time_fld = calendar_mc.time_fld;			// Setup Date Time Format Pattern			sformat_obj.setDateTimePattern ( 'MM/dd/yy h:00 a z' );			// Setup Long Month Format Pattern			mformat_obj.setDateTimePattern ( 'MMMM yyyy' );			// Setup Short Time Format Pattern			tformat_obj.setDateTimePattern ( 'h a z' );			// Ignore Hours Minutes Seconds and Milliseconds			sel_date.hours = sel_date.minutes = sel_date.seconds = sel_date.milliseconds = 0;			//			var wid:Number = input_mc.width = obj.width || input_mc.width;			// Set the Lebael Field Width			label_fld.width = wid -= 48;			// Set the Label Field Text			label_fld.htmlText = '<b>' + ( obj.label && obj.label + '       ' || '' );			// Set the Input Field Width			input_fld.width = wid -= label_fld.textWidth;			// Set the Input Field X Position			input_fld.x += label_fld.textWidth;			// Set the X Position			x = ( obj.x + 1 || x + 1 ) - 1;			// Set the Y Position			y = ( obj.y + 1 || y + 1 ) - 1;			// Set the Calendar X Position			calendar_mc.x = Math.min ( 556 - x, Math.max ( 10 - x, ( input_mc.width - 224 ) * .5 ) );			// Set the Calendar Below the Input Field			if ( y < 448 ) calendar_mc.y = 42;			// Set the Calendar Above the Input Field			else calendar_mc.y = -298;			// Show the Appropriate Month			do_month ( );			// Listen for Mouse Over Events			calendar_mc.addEventListener ( MouseEvent.MOUSE_OVER, on_btn, false, 0, true );			// Listen for Mouse Out Events			calendar_mc.addEventListener ( MouseEvent.MOUSE_OUT, on_btn, false, 0, true );			// Listen for Mouse Out Events			calendar_mc.addEventListener ( MouseEvent.CLICK, on_btn, false, 0, true );			// Listen for Key Down Events			time_fld.addEventListener ( KeyboardEvent.KEY_DOWN, on_input, false, 0, true );			// Listen for Change Events			time_fld.addEventListener ( Event.CHANGE, on_change, false, 0, true );			// Listen for Added to Stage Event			addEventListener ( Event.ADDED_TO_STAGE, on_added, false, 0, true );		}				// React to Added to Stage Event		private function on_added ( evt:Event ) : void {			// Listen for Blur Event			stage.addEventListener ( MouseEvent.MOUSE_DOWN, on_blur, false, 0, true );		}				// React to Blur Events		private function on_blur ( evt:MouseEvent ) : void {			// Save a Refernece to the Target			var tar:DisplayObject = evt.target as DisplayObject;			// Do Nothing If We Still Have Focus			if ( tar === this || contains ( tar ) ) return;			// Stop Listening for Blur Event			stage.removeEventListener ( MouseEvent.MOUSE_DOWN, on_blur );			// Remove Us From the Stage			parent.removeChild ( this );			// Dispatch an Event			dispatchEvent ( new DatePickerEvent ( { type:'done', value:sel_time.time } ) );			// Rerender After the Event			evt.updateAfterEvent ( );		}				// Show the Appropriate Month		private function do_month ( delta_val:int = 1 ) : void {			// Save a Reference to the Incremented View Date			view_date = new Date ( view_date.fullYear, view_date.month + --delta_val, 1, 0, 0, 0, 0 );			// Create a Utility Date Object			var date_obj:Date = new Date ( view_date );			// Show the Month in Long Format			calendar_mc.month_fld.htmlText = '<b>' + mformat_obj.format ( date_obj );			// Set the Date to the First Day of the Week			date_obj.date -= date_obj.day;			// Hide the Focus Rectangle			calendar_mc.focus_mc.visible = false;			// Iterate Over the Days			for ( var i:int = 42, n:int = 0; i--; ) {				// Save a Reference to the Date Hotspot				var date_btn:SimpleButton = calendar_mc [ 'date' + n + '_btn' ];				// Save a Reference to the Date Hotspot				var date_fld:TextField = calendar_mc [ 'date' + n++ + '_fld' ];				// Save a Reference to the Date				date_dic [ date_btn ] = new Date ( date_obj );				// Display the Appropriate Date				date_fld.text = date_obj.date.toString ( );				// Dsiplay Appropriate Text Color				date_fld.textColor = date_obj.month === view_date.month ? 0x333333 : 0xCCCCCC;				// Show that the Date is Selected				if ( sel_date.time === date_obj.time ) do_select ( date_btn );				// Increment the Date				date_obj.date++;			}		}				// Show the Appropriate Time		private function do_time ( delta_val:int = 1 ) : void {			// Save a Reference to the Incremented Time			sel_time = new Date ( sel_date.fullYear, sel_date.month, sel_date.date, sel_time.hours + --delta_val, 0, 0 );			// Prevent the Date from Changing			sel_time.date =  sel_date.date;			// Display the Selected Date			input_fld.text = sformat_obj.format ( sel_time );			// Display the Selected Time			time_fld.text = tformat_obj.format ( sel_time );		}				// React to Change Events 		private function on_change ( evt:Event ) : void {			// Save a Reference to the Hour 			var time_int:Number = Math.min ( 12, Math.max ( 1, parseInt ( time_fld.text ) ) );			// Show the Appropriate Time 			if ( !isNaN ( time_int ) ) do_time ( time_int - sel_time.hours + 1 );		}				// React to Key Down Events		private function on_input ( evt:KeyboardEvent ) : void {			// Save a Reference to the Time TextField Text			var time_txt:String = time_fld.text;			// Save a Reference to the Time TextField Text			var caret_ndx:int = time_fld.caretIndex;			// Save a Reference to the Index of the First Digit			var digit_ndx:int = time_txt.search ( /\D/ );			// Save a Reference to the Key Text			var key_txt:String = String.fromCharCode ( evt.charCode );			// Save a Reference to the Key Text			var key_code:String = String ( evt.keyCode );			// React to Left and Right Direction Keys			if ( /37|39/i.test ( key_code ) ) return;			// React to Up Direction Key			if ( key_code === '38' ) do_time ( 0 );			// React to Down Direction Key			if ( key_code === '40' ) do_time ( 2 );			// React to Backspace Key			if ( key_code === '8' ) {				// Check that the Caret is In the Appropriate Position				if (caret_ndx <= digit_ndx ) return;				// Place the Caret at the Appropriate Position				time_fld.setSelection ( caret_ndx - 1, caret_ndx - 1 );			}			// React to Delete Key			if ( key_code === '46' && caret_ndx < digit_ndx ) return;			// React to AM/PM Input			if ( /[pa]/i.test ( key_txt ) ) do_time ( 13 );			// React to Numeric Keys			if ( /\d/i.test ( key_txt ) && caret_ndx <= digit_ndx ) return;			// Prevent All Other Input			evt.preventDefault ( );		}						// React to Events		private function on_btn ( evt:MouseEvent ) : void {			// Do Nothing if the Target Isn't a Button			if ( ! ( /_btn$/.test ( evt.target.name ) ) ) return;			// Rerender After the Evetn			evt.updateAfterEvent ( );			// Show the Hotspot on Mouse Over			if ( evt.type === 'mouseOver' ) evt.target.alpha = 1;			// Hide the Hotspot on Mouse Out			if ( evt.type === 'mouseOut' ) evt.target.alpha = 0;			// Check for Click Events			if ( evt.type !== 'click' ) return;			// Save a Reference to the Target Name			var tar_name:String = evt.target.name;			// Check that the Target is a Month Button			if ( /^month/.test ( tar_name ) ) do_month ( parseInt ( tar_name.substr ( 5 ) ) );			// Check that the Target is a Time Button			else if ( /^time/.test ( tar_name ) ) do_time ( parseInt ( tar_name.substr ( 4 ) ) );			// Show that the Date is Selected			else do_select ( evt.target as SimpleButton );		}				// Show that the Date is Selected		private function do_select ( date_btn:SimpleButton ) : void {			// Set the Focus Rectangle's X Position			calendar_mc.focus_mc.x = date_btn.x;			// Set the Focus Rectangle's Y Position			calendar_mc.focus_mc.y = date_btn.y;			// Show the Focus Rectangle			calendar_mc.focus_mc.visible = true;			// Save a Reference to the Target Date			sel_date = date_dic [ date_btn ];			// Show the Appropriate Time			do_time ( );		}	}}