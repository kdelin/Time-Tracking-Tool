// Define the Packagepackage classes.view.grid {		// Import Necessary Classes	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.utils.getQualifiedClassName;	import flash.events.Event;		// Define the Class	internal class GridSprite extends Sprite {				// Create a Variable for the Previous Element		public var lastSiblingOfType:* = null;		// Create a Variable for the Next Element		public var nextSiblingOfType:* = null;		// Create a Variable for the Next Element		public var siblingsOfType:* = null;				// Initialise/Overwrite Properties		public function init ( obj:Object ) : void {			// Loop through Object Properties			for ( var n:String in obj ) {				// Do Nothing if Value is Undefined				if ( typeof obj [ n ] === 'undefined' ) continue;				// Overwirte Private Arguents				if ( n in this [ 'arg' ] ) this [ 'arg' ] [ n ] = obj [ n ];				// Overwirte Public Properties				else if ( n in this ) this [ n ] = obj [ n ];			}			// Iinitialize Sub Class			on_init ( );		}				// Iinitialize Sub Class		public function on_init ( ) : void { }				// Override addChild to Catalog Children		public override function addChild ( child:DisplayObject ) : DisplayObject {			// Save a Reference to the Class Name of the Child			var string:String = getQualifiedClassName ( child ).replace ( /.*\b(?=\w)/g, '' ).toLowerCase ( );			// Check that a Corellating Vector Exists			if ( string in this ) {				// Save a Reference to the Vector				var vector:* = this [ string ];				// Do Nothing if the Vector Doesn't Exist				if ( vector ) {					// Save a Reference to the Vector Length					var len:int = vector.length;					// Append the Child to the Vector					vector [ len ] = child;					// Listen for Removed Event					child.addEventListener ( Event.REMOVED, on_removed, false, 0, true );					// Save a Reference to Siblings					if ( 'siblingsOfType' in child ) child [ 'siblingsOfType' ] = vector;					// Do Nothing if the Vector Has No Previous Elements					if ( len ) {						// Save a Reference to the Previous Element						var prev:* = vector [ len - 1 ];						// Define the Child's 'Previous' Variable						if ( 'lastSiblingOfType' in child ) child [ 'lastSiblingOfType' ] = prev;						// Define the Previous Element's 'Next' Variable						if ( 'nextSiblingOfType' in prev ) prev [ 'nextSiblingOfType' ] = child;					}				}			}			// Run Default Functionality			return super.addChild ( child );		}				// Override removeChild to Catalog Children		private function on_removed ( evt:Event ) : void {			// Save a Reference to the Child			var child = evt.target;			// Save a Reference to the Class Name of the Child			var string:String = getQualifiedClassName ( child ).replace ( /.*\b(?=\w)/g, '' ).toLowerCase ( );			// Check that a Corellating Vector Exists			if ( string in this ) {				// Save a Reference to the Vector				var vector:* = this [ string ];				// Check that Vector Exists				if ( vector ) {					// Save a Reference to the Child's Index within the Vector					var index:int = vector.indexOf ( child );					// Remove Child from Vector					if ( index > -1 ) vector.splice ( index, 1 );				}			}		}	}}