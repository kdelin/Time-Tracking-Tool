// Define the Packagepackage classes.view.grid {		// Import Necessary Classes	import flash.geom.Rectangle;	import flash.events.Event;	import classes.view.inputfield.InputField;	import flash.geom.Point;		// Define the Class	internal final class GridColumn extends GridSprite {				// Define Default Arguments		internal const arg:Object = { index: 0, data: { prev: { x: 0, width: 0, concat:function ( ...e ) { return [ 0, 1, 2, 3, 4 ] } } } };		// Crate a Vector for GridHeader Objects		public var gridheader:Vector.<GridHeader> = new <GridHeader> [ ];		// Crate a Vector for GridRow Objects		public var gridrow:Vector.<GridRow> = new <GridRow> [ ];		// Create a Variable for Calcuating Drag Distance		private var moved:Number = 0;				// Instantiate the Class		public function GridColumn ( obj:Object ) : void {			// Initialize Properties			init ( obj );			// Position the Column Appropriately			x = arg.data.x;			// Add a Header Row			addChild ( new GridHeader ( { data:arg.data } ) );			// Add Row Text			for ( var n:int = 15, i:int = 0; n--; ) addChild ( new GridRow ( { y:height, data:arg.data [ i++ ] } ) );			// Add Vertial Line			addChild ( new GridVLine ( { x:-5, height:675 } ) );			// Set/Reset Event Listeners			GridListener.set ( { target:this, startResize:do_resize, stopResize:reset_mouse, resizeUpdate:on_move, dblClick:on_double, sort:on_sort } );			// Lock Data			gridheader.fixed = gridrow.fixed = true;		}				// Reset Resizing		private function reset_mouse ( evt:Event ) : void {			// Stop Resizing			stopDrag ( );		}				// React to Sort Events		private function on_sort ( evt:GridEvent ) : void {			// Save a Refernece to the Sort Index			evt.sortIndex = arg.data.sort ( 8 );		}				// React to Horizontal Scroll Events		public function h_scroll ( obj:Object ) {			// Save a Reference to the Current Column			var col:GridColumn = this;			// Save a Reference to the Current Column			var dst:Number = siblingsOfType [ obj.scroll ].x;			// Move all Columns to the Appropriate Position			if ( dst ) do col.x -= dst while ( col = col.nextSiblingOfType );		}				// React to Resizing		private function on_move ( evt:Event ) : void {			// Save a Refernce to the Distance Moved			var dst:Number = moved - ( moved = x );			// Save a Reference to the Current Column			var col:GridColumn = this;			// Move all Columns to the Right			while ( col = col.nextSiblingOfType ) col.x -= dst;		}				// Start Resizing		private function do_resize ( evt:Event ) : void {			// Save a Reference to the Left Column			var col:GridColumn = lastSiblingOfType;			// Calculate Drag Area			var rec:Rectangle = new Rectangle ( col.x + 156, y, col.width, 0 );			// Save the Current Position			moved = x;			// Start Resizing			startDrag ( false, rec );		}				// React to Double Click Event		private function on_double ( obj:GridEvent ) : void {			// Save a Reference to the Left Position			var pnt:Point = parent.localToGlobal ( new Point ( Math.max ( 0, x - 4.5 ), 0 ) );			// Save a Reference to the Width			var dif:Number = parent.localToGlobal ( new Point ( nextSiblingOfType.x, 0 ) ).x - pnt.x - 4;			// Save a Reference to the Init Object			var nfo:Object = { text:obj.data.value, x:pnt.x, y:obj.y, width:dif };			// Display the Appropriate TextField			GridListener.set ( { target: stage.addChild ( new InputField ( nfo ) ), done: [ obj.done, gridheader [ 0 ].no_arrow ] } );		}	}}