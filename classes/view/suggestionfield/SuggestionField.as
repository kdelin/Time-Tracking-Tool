<<<<<<< HEAD
<<<<<<< HEAD
﻿// Define the Packagepackage classes.view.suggestionfield {		// Import Necessary Classes	import flash.text.TextField;	import flash.events.MouseEvent;	import flash.display.Sprite;	import flash.utils.setInterval;	import flash.utils.clearInterval;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.utils.setTimeout;		// Define the Class	public final class SuggestionField extends Sprite {				// Save a Reference to List Options		private var vls:Array = [ 'Option Aaaa', 'Option Aaab', 'Option Aaac', 'Option Aabb', 'Option Aabc', 'Option Abbb', 'Option Abbc', 'Option Abcc', 'Option Accc', 'Option Bbbb', 'Option Bbbc', 'Option Bbcc', 'Option Bccc', 'Option Cccc', 'Option Dddd', 'Option Ddde', 'Option Dddf', 'Option Ddee', 'Option Ddef', 'Option Ddff', 'Option Deee', 'Option Deef', 'Option Deff', 'Option Dfff', 'Option Eeee', 'Option Eeef', 'Option Eeff', 'Option Efff', 'Option Ffff' ];		// Create a Variable for List Option TextFields		private var opt:Vector.<TextField>;		// Create a Variable for Scroll Arrow Buttons		private var arw:Vector.<Sprite>;		// Create a Variable for Background Sprites		private var bgs:Vector.<Sprite>;		// Create a Variable for Input and Hint TextFields		private var npt:Vector.<TextField>;		// Create a Variable for Hilighted List Option TextField		private var hig:TextField;		// Save a Refernece to Input TextField Text		private var txt:String = '';		// Save a Reference to the Scroll Position		private var scr:int = 0;		// Create a Variable for Delayed Function Calls		private var tme:int = 0;		// Create a Variable for Displayed Filtered Options		private var flt:Array;		// Create a Variable for the Number of Visible List Options		private var rws:int;		// Create a Variable for the Number of Filtered List Options		private var len:int;				// Instantiate the Class		public function SuggestionField ( obj:Object ) : void {			// Save a Refernece to List Option TextFields			opt = new <TextField> [ list_mc.fld0, list_mc.fld1, list_mc.fld2, list_mc.fld3, list_mc.fld4, list_mc.fld5, list_mc.fld6, list_mc.fld7, list_mc.fld8, list_mc.fld9, list_mc.fld10, list_mc.fld11, list_mc.fld12, list_mc.fld13, list_mc.fld14, list_mc.fld15, list_mc.fld16, list_mc.fld17, list_mc.fld18, list_mc.fld19, list_mc.fld20, list_mc.fld21, list_mc.fld22, list_mc.fld23 ];			// Save a Refernece to Scroll Arrow Buttons			arw = new <Sprite> [ list_mc.up_btn, list_mc.down_btn ];			// Save a Reference to Background Sprites			bgs = new <Sprite> [ input_bg, list_mc.list_bg ];			// Save a Reference to Input and Hint TextFields			npt = new <TextField> [ input_fld, hint_fld ];			// Lock Vectors for Iteration Optimisation			opt.fixed = arw.fixed = bgs.fixed = npt.fixed = true;			// Save a Reference to the Object Width			var wid:Number = obj.width || 195;			// Save a Reference to the			vls = ( obj.hints as Array ) || vls;			// Dsiplay the Label TextField Text			label_fld.htmlText = '<b>' + ( obj.label && obj.label + '       ' || '' );			// Dsiplay the Default Input TextField Text			input_fld.text = obj.value || input_fld.text;			// Position the Input and Hint TextFields			input_fld.x = hint_fld.x += label_fld.textWidth;			// Set the X Position			x = obj.x || x;			// Set the Y Position			y = obj.y || y;			// Set the Width of the Input TextField Background			input_bg.width = wid;			// Set the Width of the List Option TextFields			for each ( var np:TextField in npt ) np.width = wid - 48 - label_fld.textWidth;			// Set the Width of the Input TextField Background			list_mc.list_bg.width = wid += 3;			// Loop through the Scroll Arrow Buttons			for each ( var btn:Object in arw ) {				// Set the Width of the Scroll Arrow Buttons				btn.arrow_mc.x = ( wid - 14 ) * .5;				// Vertically Align the Arrows				btn.getChildAt ( 0 ).width = wid - 14;				// Prevent Errant Events				btn.mouseChildren = false;				// Listen for Mouse Over Events				btn.addEventListener ( MouseEvent.MOUSE_OVER, on_over );				// Listen for Mouse Out Events				btn.addEventListener ( MouseEvent.MOUSE_OUT, on_out );			}			// Loop through the List Option TextFields			for each ( var fld:TextField in opt ) {				// Set the Width of the List Option TextFields				fld.width = wid - 14;				// Listen for Mouse Over Events				fld.addEventListener ( MouseEvent.MOUSE_OVER, on_over, false, 0, true );				// Listen for Mouse Out Events				fld.addEventListener ( MouseEvent.MOUSE_OUT, on_out, false, 0, true );				// Listen for Click Events				fld.addEventListener ( MouseEvent.CLICK, on_click, false, 0, true );			}			// Listen for Change Events			input_fld.addEventListener ( Event.CHANGE, on_change );			// Listen for Added to Stage Event			addEventListener ( Event.ADDED_TO_STAGE, on_added );			// React to Change Events			on_change ( null );		}				// React to Added to Stage Event		function on_added ( evt:Event ) : void {			// Listen for KeyDown Events			stage.addEventListener ( KeyboardEvent.KEY_DOWN, on_key, false, 0, true );			// Focus on the Input Field			stage.focus = input_fld;			// Select the Input Field Text			input_fld.setSelection ( 9999, 9999 );		}				// React to KeyDown Events		private function on_key ( evt:KeyboardEvent ) : void {			// Save a Reference to the KeyCode			var cde:int = evt.keyCode;			// Scroll Downwards on Down Arrow Key Press			if ( cde === 40 ) do_hilight ( 1 );			// Scroll Upwards on Up Arrow Key Press			else if ( cde === 38 ) do_hilight ( -1 );			// Autofil Input TextField on Right Arrow Key Press			else if ( cde === 39 && input_fld.caretIndex === input_fld.length ) do_autofill ( );			// Autofil Input TextField on Enter Key Press			else if ( cde === 13 ) do_autofill ( );			// Do Nothing Further if Other Keys Were Pressed			else return;			// Prevent Event Default Behavior			evt.preventDefault ( );		}				// React to Change Events		private function on_change ( evt ) : void {			// Save a Reference to the List Options			var all:String = String ( '\n' + vls.join ( '\t\n' ) );			// Save a Reference to the Input Field Text			var _txt = txt = input_fld.text;			// Save a Refernece to All List Options			if ( _txt ) flt = all.match ( new RegExp ( '\n' + _txt.replace ( /(\W)/gi, '\\$1' ) + '[^\t\n]*', 'gi' ) )			// Save a Refernece to All List Options			if ( !flt || !_txt ) flt = all.split ( '\t' );			// Save a Reference to the Number of Filtered List Options			var _len:int = len = flt.length;			// Hide/Show List Options			list_mc.visible = _len > 1 || !txt;			// Hide/Show Hint TextField			hint_fld.visible = _len || !txt;			// Save a Reference to the Number of Visible List Options			var _rws:int = rws = max ( 0,  min ( opt.length - 1, min ( _len, ( 800 - y - 59 ) / 30 ) ) );			// Set the Height of the List Background			bgs [ 1 ].height = _rws * 30 + 14;			// Set the Position of the Bottom Scroll Arrow			arw [ 1 ].y = opt [ _rws ].y			// Display the Appropriate List Options			do_options ( );			// Simulate a Mouse Over of the First List Option TextField			on_over ( { target: opt [ 0 ] } );		}				// React to Mouse Over Events		private function on_over ( evt:Object ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Check that the Event Target is a List Option TextField			if ( tar is TextField ) {				// Unhilight Previously Hilighted List Option TextField				if ( hig ) hig.opaqueBackground = null;				// Hilight the Currnet List Option TextField				tar.opaqueBackground = 0xEFEFEF;				// Save a Refernec to the Currnetly Hilighted List Option TextField				hig = tar as TextField;				// Display the Appropriate Hint				hint_fld.htmlText = '<font color="#FFFFFF">' + txt + '</font>' + tar.text.substr ( 1 + txt.length );			}			// Hilight the Scroll Arrow Button			if ( arw.indexOf ( tar ) + 1 )  tar.arrow_mc.alpha = .75;			// Scroll the List Options Upwards			if ( tar.name === 'down_btn' ) do_scroll ( 1 );			// Scroll the List Options Downwards			if ( tar.name === 'up_btn' ) do_scroll ( -1 );			// Rerender After the Event			if ( evt.updateAfterEvent ) evt.updateAfterEvent ( );		}				// React to Mouse Out Events		private function on_out ( evt:Object ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Rerender After the Event			if ( evt.updateAfterEvent ) evt.updateAfterEvent ( );			// Check that the Event Target is a Scroll Arrow Button			if ( arw.indexOf ( tar ) + 1 ) {				// Unhighlight the Scroll Arrow Button				tar.arrow_mc.alpha = 1;				// Clear Any Delayed Function Calls				clearInterval ( tme );			}		}				// React to Click Events		private function on_click ( evt:MouseEvent ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Autofill Input TextField			do_autofill ( );			// Rerender After the Event			evt.updateAfterEvent ( );		}				// Autofill Input TextField		private function do_autofill ( ) : void {			// Save a Refrenece to the Hint Text			var hnt:String = hint_fld.text;			// Do Nothig if No Hint Exists			if ( !hnt || !hint_fld.visible ) return;			// Update the Input TextField Text			input_fld.text = hnt;			// Move the Input TextField Caret to the End			input_fld.setSelection ( hnt.length, hnt.length );			// React the Text Change			on_change ( null );		}				// Increment/Decrement the Hilighted List Option TextField		private function do_hilight ( dir:int = 0 ) : void {			// Determine the List Option TextField Index			var ndx:int = opt.indexOf ( hig ) + dir;			// Check that The List Should Scroll Upwards			if ( ndx === 0 && arw [ 0 ].visible ) {				// Scroll the List Upwards				do_scroll ( -1, false );				// Hilight the Appropriate List Option TextField				on_over ( { target: opt [ 1 ] } );			}			// Check that The List Should Scroll Dowmwards			else if ( ndx === rws - 1 && arw [ 1 ].visible ) {				// Scroll the List Dowmwards				do_scroll ( 1, false );				// Hilight the Appropriate List Option TextField				on_over ( { target: opt [ rws - 2 ] } );			}			// Hilight the Appropriate List Option TextField			else on_over ( { target: opt [ min ( rws - 1, max ( 0, ndx ) ) ] } );		}				// Scroll the List Upwards or Downwards		private function do_scroll ( dir:int = 0, rec:Boolean = true ) : void {			// Display the Appropriate List Options			do_options ( scr = min ( len - rws, max ( 0, scr + dir ) ) );			// Clear Any Delayed Function Calls			clearInterval ( tme );			// Scroll the List Again after a Delay			if ( rec ) tme = setTimeout ( do_scroll, 100, dir );		}				// Display the Appropriate List Options		private function do_options ( min:int = 0 ) : void {			// Save Local References to Global Variables			var _rws:int = rws, _len:int = len, _flt:Array = flt, _opt:Vector.<TextField> = opt;			// Save a Refernece to the Starting Index			var i:int = min < 0 ? 0 : min >= _len - rws ? _len - _rws : min > 0 ? min - 1 : 0;			// Display/Hide the Up Scroll Arrow Button			arw [ 0 ].visible = min > 0;			// Display/Hide the Down Scroll Arrow Button			arw [ 1 ].visible = min + _rws < _len - 1;			// Loop through the List Option TextFields			for ( var n:int = _opt.length, m:int = 0; n--; ) {				// Save a Refernece to the Current List Option TextField				var fld:TextField = _opt [ m++ ];				// Display the Appropriate List Option Text				fld.text = _flt [ i++ ] || '';				// Display/Hide the List Option TextField				fld.visible = m <= _rws;			}		}				// Calculate Math.min But Faster		private function min ( a:Number, b:Number ) : Number { return a < b ? a : b }				// Calculate Math.max But Faster		private function max ( a:Number, b:Number ) : Number { return a > b ? a : b }	}}
=======
﻿// Define the Packagepackage classes.view.suggestionfield {		// Import Necessary Classes	import flash.text.TextField;	import flash.events.MouseEvent;	import flash.display.Sprite;	import flash.utils.setInterval;	import flash.utils.clearInterval;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.utils.setTimeout;	import flash.display.DisplayObject;		// Define the Class	public final class SuggestionField extends Sprite {				// Save a Reference to List Options		private var vls:Array = [ 'Option Aaaa', 'Option Aaab', 'Option Aaac', 'Option Aabb', 'Option Aabc', 'Option Abbb', 'Option Abbc', 'Option Abcc', 'Option Accc', 'Option Bbbb', 'Option Bbbc', 'Option Bbcc', 'Option Bccc', 'Option Cccc', 'Option Dddd', 'Option Ddde', 'Option Dddf', 'Option Ddee', 'Option Ddef', 'Option Ddff', 'Option Deee', 'Option Deef', 'Option Deff', 'Option Dfff', 'Option Eeee', 'Option Eeef', 'Option Eeff', 'Option Efff', 'Option Ffff' ];		// Create a Variable for List Option TextFields		private var opt:Vector.<TextField>;		// Create a Variable for Scroll Arrow Buttons		private var arw:Vector.<Sprite>;		// Create a Variable for Background Sprites		private var bgs:Vector.<Sprite>;		// Create a Variable for Input and Hint TextFields		private var npt:Vector.<TextField>;		// Create a Variable for Hilighted List Option TextField		private var hig:TextField;		// Save a Refernece to Input TextField Text		private var txt:String = '';		// Save a Reference to the Scroll Position		private var scr:int = 0;		// Create a Variable for Delayed Function Calls		private var tme:int = 0;		// Create a Variable for Displayed Filtered Options		private var flt:Array;		// Create a Variable for the Number of Visible List Options		private var rws:int;		// Create a Variable for the Number of Filtered List Options		private var len:int;				// Instantiate the Class		public function SuggestionField ( obj:Object ) : void {			// Save a Refernece to List Option TextFields			opt = new <TextField> [ list_mc.fld0, list_mc.fld1, list_mc.fld2, list_mc.fld3, list_mc.fld4, list_mc.fld5, list_mc.fld6, list_mc.fld7, list_mc.fld8, list_mc.fld9, list_mc.fld10, list_mc.fld11, list_mc.fld12, list_mc.fld13, list_mc.fld14, list_mc.fld15, list_mc.fld16, list_mc.fld17, list_mc.fld18, list_mc.fld19, list_mc.fld20, list_mc.fld21, list_mc.fld22, list_mc.fld23 ];			// Save a Refernece to Scroll Arrow Buttons			arw = new <Sprite> [ list_mc.up_btn, list_mc.down_btn ];			// Save a Reference to Background Sprites			bgs = new <Sprite> [ input_bg, list_mc.list_bg ];			// Save a Reference to Input and Hint TextFields			npt = new <TextField> [ input_fld, hint_fld ];			// Lock Vectors for Iteration Optimisation			opt.fixed = arw.fixed = bgs.fixed = npt.fixed = true;			// Save a Reference to the Object Width			var wid:Number = obj.width || 195;			// Save a Reference to the			vls = ( obj.hints as Array ) || vls;			// Dsiplay the Label TextField Text			label_fld.htmlText = '<b>' + ( obj.label && obj.label + '       ' || '' );			// Dsiplay the Default Input TextField Text			input_fld.text = obj.value || input_fld.text;			// Position the Input and Hint TextFields			input_fld.x = hint_fld.x += label_fld.textWidth;			// Set the X Position			x = obj.x || x;			// Set the Y Position			y = obj.y || y;			// Set the Width of the Input TextField Background			input_bg.width = wid;			// Set the Width of the List Option TextFields			for each ( var np:TextField in npt ) np.width = wid - 48 - label_fld.textWidth;			// Set the Width of the Input TextField Background			list_mc.list_bg.width = wid += 3;			// Loop through the Scroll Arrow Buttons			for each ( var btn:Object in arw ) {				// Set the Width of the Scroll Arrow Buttons				btn.arrow_mc.x = ( wid - 14 ) * .5;				// Vertically Align the Arrows				btn.getChildAt ( 0 ).width = wid - 14;				// Prevent Errant Events				btn.mouseChildren = false;				// Listen for Mouse Over Events			}			// Set the Width of the List Option TextFields			for each ( var fld:TextField in opt ) fld.width = wid - 14;			// Listen for Mouse Over Events			addEventListener ( MouseEvent.MOUSE_OVER, on_over, false, 0, true );			// Listen for Mouse Out Events			addEventListener ( MouseEvent.MOUSE_OUT, on_out, false, 0, true );			// Listen for Click Events			addEventListener ( MouseEvent.CLICK, on_click, false, 0, true );			// Listen for Change Events			addEventListener ( Event.CHANGE, on_change, false, 0, true );			// Listen for Added to Stage Event			addEventListener ( Event.ADDED_TO_STAGE, on_added, false, 0, true );			// React to Change Events			on_change ( null );		}				// React to Added to Stage Event		function on_added ( evt:Event ) : void {			// Listen for KeyDown Events			stage.addEventListener ( KeyboardEvent.KEY_DOWN, on_key, false, 0, true );			// Listen for Mouse Down Events			stage.addEventListener ( MouseEvent.MOUSE_DOWN, on_down, false, 0, true );			// Focus on the Input Field			stage.focus = input_fld;			// Select the Input Field Text			input_fld.setSelection ( 9999, 9999 );		}				// React to KeyDown Events		private function on_key ( evt:KeyboardEvent ) : void {			// Save a Reference to the KeyCode			var cde:int = evt.keyCode;			// Scroll Downwards on Down Arrow Key Press			if ( cde === 40 ) do_hilight ( 1 );			// Scroll Upwards on Up Arrow Key Press			else if ( cde === 38 ) do_hilight ( -1 );			// Autofil Input TextField on Right Arrow Key Press			else if ( cde === 39 && input_fld.caretIndex === input_fld.length ) do_autofill ( );			// Autofil Input TextField on Enter Key Press			else if ( cde === 13 ) do_autofill ( );			// Do Nothing Further if Other Keys Were Pressed			else return;			// Prevent Event Default Behavior			evt.preventDefault ( );		}				// React to Change Events		private function on_change ( evt ) : void {			// Save a Reference to the List Options			var all:String = String ( '\n' + vls.join ( '\t\n' ) );			// Save a Reference to the Input Field Text			var _txt = txt = input_fld.text;			// Save a Refernece to All List Options			if ( _txt ) flt = all.match ( new RegExp ( '\n' + _txt.replace ( /(\W)/gi, '\\$1' ) + '[^\t\n]*', 'gi' ) )			// Save a Refernece to All List Options			if ( !flt || !_txt ) flt = all.split ( '\t' );			// Save a Reference to the Number of Filtered List Options			var _len:int = len = flt.length;			// Hide/Show List Options			list_mc.visible = _len > 1 || !txt;			// Hide/Show Hint TextField			hint_fld.visible = _len || !txt;			// Save a Reference to the Number of Visible List Options			var _rws:int = rws = max ( 0,  min ( opt.length - 1, min ( _len, ( 800 - y - 59 ) / 30 ) ) );			// Set the Height of the List Background			bgs [ 1 ].height = _rws * 30 + 14;			// Set the Position of the Bottom Scroll Arrow			arw [ 1 ].y = opt [ _rws ].y			// Display the Appropriate List Options			do_options ( );			// Simulate a Mouse Over of the First List Option TextField			on_over ( { target: opt [ 0 ] } );		}				// React to Mouse Over Events		private function on_over ( evt:Object ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Check that the Event Target is a List Option TextField			if ( opt.indexOf ( tar ) + 1 ) {				// Unhilight Previously Hilighted List Option TextField				if ( hig ) hig.opaqueBackground = null;				// Hilight the Currnet List Option TextField				tar.opaqueBackground = 0xEFEFEF;				// Save a Refernec to the Currnetly Hilighted List Option TextField				hig = tar as TextField;				// Display the Appropriate Hint				hint_fld.htmlText = '<font color="#FFFFFF">' + txt + '</font>' + tar.text.substr ( 1 + txt.length );			}			// Hilight the Scroll Arrow Button			if ( arw.indexOf ( tar ) + 1 )  tar.arrow_mc.alpha = .75;			// Scroll the List Options Upwards			if ( tar.name === 'down_btn' ) do_scroll ( 1 );			// Scroll the List Options Downwards			if ( tar.name === 'up_btn' ) do_scroll ( -1 );			// Rerender After the Event			if ( evt.updateAfterEvent ) evt.updateAfterEvent ( );		}				// React to Mouse Out Events		private function on_out ( evt:Object ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Rerender After the Event			if ( evt.updateAfterEvent ) evt.updateAfterEvent ( );			// Check that the Event Target is a Scroll Arrow Button			if ( arw.indexOf ( tar ) + 1 ) {				// Unhighlight the Scroll Arrow Button				tar.arrow_mc.alpha = 1;				// Clear Any Delayed Function Calls				clearInterval ( tme );			}		}				// React to Click Events		private function on_click ( evt:MouseEvent ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Do Nothing If the Target Is Not a List Option TextField			if ( opt.indexOf ( tar ) === -1 ) return;			// Autofill Input TextField			do_autofill ( );			// Rerender After the Event			evt.updateAfterEvent ( );		}				// React to Mouse Down Events		private function on_down ( evt:MouseEvent ) : void {			// Save a Refernece to the Target			var tar:DisplayObject = evt.target as DisplayObject;			// Do Nothing If We Still Have Focus			if ( tar === this || contains ( tar ) ) return;			// Stop Listening for Mouse Down Events			stage.removeEventListener ( MouseEvent.MOUSE_DOWN, on_down );			// Remove Us From the Stage			parent.removeChild ( this );			// Dispatch an Event			dispatchEvent ( new SuggestionFieldEvent ( { type:'done', value:input_fld.text } ) );			// Rerender After the Event			evt.updateAfterEvent ( );		}				// Autofill Input TextField		private function do_autofill ( ) : void {			// Save a Refrenece to the Hint Text			var hnt:String = hint_fld.text;			// Do Nothig if No Hint Exists			if ( !hnt || !hint_fld.visible ) return;			// Update the Input TextField Text			input_fld.text = hnt;			// Move the Input TextField Caret to the End			input_fld.setSelection ( hnt.length, hnt.length );			// React the Text Change			on_change ( null );		}				// Increment/Decrement the Hilighted List Option TextField		private function do_hilight ( dir:int = 0 ) : void {			// Determine the List Option TextField Index			var ndx:int = opt.indexOf ( hig ) + dir;			// Check that The List Should Scroll Upwards			if ( ndx === 0 && arw [ 0 ].visible ) {				// Scroll the List Upwards				do_scroll ( -1, false );				// Hilight the Appropriate List Option TextField				on_over ( { target: opt [ 1 ] } );			}			// Check that The List Should Scroll Dowmwards			else if ( ndx === rws - 1 && arw [ 1 ].visible ) {				// Scroll the List Dowmwards				do_scroll ( 1, false );				// Hilight the Appropriate List Option TextField				on_over ( { target: opt [ rws - 2 ] } );			}			// Hilight the Appropriate List Option TextField			else on_over ( { target: opt [ min ( rws - 1, max ( 0, ndx ) ) ] } );		}				// Scroll the List Upwards or Downwards		private function do_scroll ( dir:int = 0, rec:Boolean = true ) : void {			// Display the Appropriate List Options			do_options ( scr = min ( len - rws, max ( 0, scr + dir ) ) );			// Clear Any Delayed Function Calls			clearInterval ( tme );			// Scroll the List Again after a Delay			if ( rec ) tme = setTimeout ( do_scroll, 100, dir );		}				// Display the Appropriate List Options		private function do_options ( min:int = 0 ) : void {			// Save Local References to Global Variables			var _rws:int = rws, _len:int = len, _flt:Array = flt, _opt:Vector.<TextField> = opt;			// Save a Refernece to the Starting Index			var i:int = min < 0 ? 0 : min >= _len - rws ? _len - _rws : min > 0 ? min - 1 : 0;			// Display/Hide the Up Scroll Arrow Button			arw [ 0 ].visible = min > 0;			// Display/Hide the Down Scroll Arrow Button			arw [ 1 ].visible = min + _rws < _len - 1;			// Loop through the List Option TextFields			for ( var n:int = _opt.length, m:int = 0; n--; ) {				// Save a Refernece to the Current List Option TextField				var fld:TextField = _opt [ m++ ];				// Display the Appropriate List Option Text				fld.text = _flt [ i++ ] || '';				// Display/Hide the List Option TextField				fld.visible = m <= _rws;			}		}				// Calculate Math.min But Faster		private function min ( a:Number, b:Number ) : Number { return a < b ? a : b }				// Calculate Math.max But Faster		private function max ( a:Number, b:Number ) : Number { return a > b ? a : b }	}}
>>>>>>> 3b35c7c759795703c8f64e85f067bdd4223cd508
=======
﻿// Define the Packagepackage classes.view.suggestionfield {		// Import Necessary Classes	import flash.text.TextField;	import flash.events.MouseEvent;	import flash.display.Sprite;	import flash.utils.setInterval;	import flash.utils.clearInterval;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.utils.setTimeout;	import flash.display.DisplayObject;		// Define the Class	public final class SuggestionField extends Sprite {				// Save a Reference to List Options		private var vls:Array = [ 'Option Aaaa', 'Option Aaab', 'Option Aaac', 'Option Aabb', 'Option Aabc', 'Option Abbb', 'Option Abbc', 'Option Abcc', 'Option Accc', 'Option Bbbb', 'Option Bbbc', 'Option Bbcc', 'Option Bccc', 'Option Cccc', 'Option Dddd', 'Option Ddde', 'Option Dddf', 'Option Ddee', 'Option Ddef', 'Option Ddff', 'Option Deee', 'Option Deef', 'Option Deff', 'Option Dfff', 'Option Eeee', 'Option Eeef', 'Option Eeff', 'Option Efff', 'Option Ffff' ];		// Create a Variable for List Option TextFields		private var opt:Vector.<TextField>;		// Create a Variable for Scroll Arrow Buttons		private var arw:Vector.<Sprite>;		// Create a Variable for Background Sprites		private var bgs:Vector.<Sprite>;		// Create a Variable for Input and Hint TextFields		private var npt:Vector.<TextField>;		// Create a Variable for Hilighted List Option TextField		private var hig:TextField;		// Save a Refernece to Input TextField Text		private var txt:String = '';		// Save a Reference to the Scroll Position		private var scr:int = 0;		// Create a Variable for Delayed Function Calls		private var tme:int = 0;		// Create a Variable for Displayed Filtered Options		private var flt:Array;		// Create a Variable for the Number of Visible List Options		private var rws:int;		// Create a Variable for the Number of Filtered List Options		private var len:int;				// Instantiate the Class		public function SuggestionField ( obj:Object ) : void {			// Save a Refernece to List Option TextFields			opt = new <TextField> [ list_mc.fld0, list_mc.fld1, list_mc.fld2, list_mc.fld3, list_mc.fld4, list_mc.fld5, list_mc.fld6, list_mc.fld7, list_mc.fld8, list_mc.fld9, list_mc.fld10, list_mc.fld11, list_mc.fld12, list_mc.fld13, list_mc.fld14, list_mc.fld15, list_mc.fld16, list_mc.fld17, list_mc.fld18, list_mc.fld19, list_mc.fld20, list_mc.fld21, list_mc.fld22, list_mc.fld23 ];			// Save a Refernece to Scroll Arrow Buttons			arw = new <Sprite> [ list_mc.up_btn, list_mc.down_btn ];			// Save a Reference to Background Sprites			bgs = new <Sprite> [ input_bg, list_mc.list_bg ];			// Save a Reference to Input and Hint TextFields			npt = new <TextField> [ input_fld, hint_fld ];			// Lock Vectors for Iteration Optimisation			opt.fixed = arw.fixed = bgs.fixed = npt.fixed = true;			// Save a Reference to the Object Width			var wid:Number = obj.width || 195;			// Save a Reference to the			vls = ( obj.hints as Array ) || vls;			// Dsiplay the Label TextField Text			label_fld.htmlText = '<b>' + ( obj.label && obj.label + '       ' || '' );			// Dsiplay the Default Input TextField Text			input_fld.text = obj.value || input_fld.text;			// Position the Input and Hint TextFields			input_fld.x = hint_fld.x += label_fld.textWidth;			// Set the X Position			x = obj.x || x;			// Set the Y Position			y = obj.y || y;			// Set the Width of the Input TextField Background			input_bg.width = wid;			// Set the Width of the List Option TextFields			for each ( var np:TextField in npt ) np.width = wid - 48 - label_fld.textWidth;			// Set the Width of the Input TextField Background			list_mc.list_bg.width = wid += 3;			// Loop through the Scroll Arrow Buttons			for each ( var btn:Object in arw ) {				// Set the Width of the Scroll Arrow Buttons				btn.arrow_mc.x = ( wid - 14 ) * .5;				// Vertically Align the Arrows				btn.getChildAt ( 0 ).width = wid - 14;				// Prevent Errant Events				btn.mouseChildren = false;				// Listen for Mouse Over Events			}			// Set the Width of the List Option TextFields			for each ( var fld:TextField in opt ) fld.width = wid - 14;			// Listen for Mouse Over Events			addEventListener ( MouseEvent.MOUSE_OVER, on_over, false, 0, true );			// Listen for Mouse Out Events			addEventListener ( MouseEvent.MOUSE_OUT, on_out, false, 0, true );			// Listen for Click Events			addEventListener ( MouseEvent.CLICK, on_click, false, 0, true );			// Listen for Change Events			addEventListener ( Event.CHANGE, on_change, false, 0, true );			// Listen for Added to Stage Event			addEventListener ( Event.ADDED_TO_STAGE, on_added, false, 0, true );			// React to Change Events			on_change ( null );		}				// React to Added to Stage Event		function on_added ( evt:Event ) : void {			// Listen for KeyDown Events			stage.addEventListener ( KeyboardEvent.KEY_DOWN, on_key, false, 0, true );			// Listen for Mouse Down Events			stage.addEventListener ( MouseEvent.MOUSE_DOWN, on_down, false, 0, true );			// Focus on the Input Field			stage.focus = input_fld;			// Select the Input Field Text			input_fld.setSelection ( 9999, 9999 );		}				// React to KeyDown Events		private function on_key ( evt:KeyboardEvent ) : void {			// Save a Reference to the KeyCode			var cde:int = evt.keyCode;			// Scroll Downwards on Down Arrow Key Press			if ( cde === 40 ) do_hilight ( 1 );			// Scroll Upwards on Up Arrow Key Press			else if ( cde === 38 ) do_hilight ( -1 );			// Autofil Input TextField on Right Arrow Key Press			else if ( cde === 39 && input_fld.caretIndex === input_fld.length ) do_autofill ( );			// Autofil Input TextField on Enter Key Press			else if ( cde === 13 ) do_autofill ( );			// Do Nothing Further if Other Keys Were Pressed			else return;			// Prevent Event Default Behavior			evt.preventDefault ( );		}				// React to Change Events		private function on_change ( evt ) : void {			// Save a Reference to the List Options			var all:String = String ( '\n' + vls.join ( '\t\n' ) );			// Save a Reference to the Input Field Text			var _txt = txt = input_fld.text;			// Save a Refernece to All List Options			if ( _txt ) flt = all.match ( new RegExp ( '\n' + _txt.replace ( /(\W)/gi, '\\$1' ) + '[^\t\n]*', 'gi' ) )			// Save a Refernece to All List Options			if ( !flt || !_txt ) flt = all.split ( '\t' );			// Save a Reference to the Number of Filtered List Options			var _len:int = len = flt.length;			// Hide/Show List Options			list_mc.visible = _len > 1 || !txt;			// Hide/Show Hint TextField			hint_fld.visible = _len || !txt;			// Save a Reference to the Number of Visible List Options			var _rws:int = rws = max ( 0,  min ( opt.length - 1, min ( _len, ( 800 - y - 59 ) / 30 ) ) );			// Set the Height of the List Background			bgs [ 1 ].height = _rws * 30 + 14;			// Set the Position of the Bottom Scroll Arrow			arw [ 1 ].y = opt [ _rws ].y			// Display the Appropriate List Options			do_options ( );			// Simulate a Mouse Over of the First List Option TextField			on_over ( { target: opt [ 0 ] } );		}				// React to Mouse Over Events		private function on_over ( evt:Object ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Check that the Event Target is a List Option TextField			if ( opt.indexOf ( tar ) + 1 ) {				// Unhilight Previously Hilighted List Option TextField				if ( hig ) hig.opaqueBackground = null;				// Hilight the Currnet List Option TextField				tar.opaqueBackground = 0xEFEFEF;				// Save a Refernec to the Currnetly Hilighted List Option TextField				hig = tar as TextField;				// Display the Appropriate Hint				hint_fld.htmlText = '<font color="#FFFFFF">' + txt + '</font>' + tar.text.substr ( 1 + txt.length );			}			// Hilight the Scroll Arrow Button			if ( arw.indexOf ( tar ) + 1 )  tar.arrow_mc.alpha = .75;			// Scroll the List Options Upwards			if ( tar.name === 'down_btn' ) do_scroll ( 1 );			// Scroll the List Options Downwards			if ( tar.name === 'up_btn' ) do_scroll ( -1 );			// Rerender After the Event			if ( evt.updateAfterEvent ) evt.updateAfterEvent ( );		}				// React to Mouse Out Events		private function on_out ( evt:Object ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Rerender After the Event			if ( evt.updateAfterEvent ) evt.updateAfterEvent ( );			// Check that the Event Target is a Scroll Arrow Button			if ( arw.indexOf ( tar ) + 1 ) {				// Unhighlight the Scroll Arrow Button				tar.arrow_mc.alpha = 1;				// Clear Any Delayed Function Calls				clearInterval ( tme );			}		}				// React to Click Events		private function on_click ( evt:MouseEvent ) : void {			// Save a Reference to the Event Target			var tar:Object = evt.target;			// Do Nothing If the Target Is Not a List Option TextField			if ( opt.indexOf ( tar ) === -1 ) return;			// Autofill Input TextField			do_autofill ( );			// Rerender After the Event			evt.updateAfterEvent ( );		}				// React to Mouse Down Events		private function on_down ( evt:MouseEvent ) : void {			// Save a Refernece to the Target			var tar:DisplayObject = evt.target as DisplayObject;			// Do Nothing If We Still Have Focus			if ( tar === this || contains ( tar ) ) return;			// Stop Listening for Mouse Down Events			stage.removeEventListener ( MouseEvent.MOUSE_DOWN, on_down );			// Remove Us From the Stage			parent.removeChild ( this );			// Dispatch an Event			dispatchEvent ( new SuggestionFieldEvent ( { type:'done', value:input_fld.text } ) );			// Rerender After the Event			evt.updateAfterEvent ( );		}				// Autofill Input TextField		private function do_autofill ( ) : void {			// Save a Refrenece to the Hint Text			var hnt:String = hint_fld.text;			// Do Nothig if No Hint Exists			if ( !hnt || !hint_fld.visible ) return;			// Update the Input TextField Text			input_fld.text = hnt;			// Move the Input TextField Caret to the End			input_fld.setSelection ( hnt.length, hnt.length );			// React the Text Change			on_change ( null );		}				// Increment/Decrement the Hilighted List Option TextField		private function do_hilight ( dir:int = 0 ) : void {			// Determine the List Option TextField Index			var ndx:int = opt.indexOf ( hig ) + dir;			// Check that The List Should Scroll Upwards			if ( ndx === 0 && arw [ 0 ].visible ) {				// Scroll the List Upwards				do_scroll ( -1, false );				// Hilight the Appropriate List Option TextField				on_over ( { target: opt [ 1 ] } );			}			// Check that The List Should Scroll Dowmwards			else if ( ndx === rws - 1 && arw [ 1 ].visible ) {				// Scroll the List Dowmwards				do_scroll ( 1, false );				// Hilight the Appropriate List Option TextField				on_over ( { target: opt [ rws - 2 ] } );			}			// Hilight the Appropriate List Option TextField			else on_over ( { target: opt [ min ( rws - 1, max ( 0, ndx ) ) ] } );		}				// Scroll the List Upwards or Downwards		private function do_scroll ( dir:int = 0, rec:Boolean = true ) : void {			// Display the Appropriate List Options			do_options ( scr = min ( len - rws, max ( 0, scr + dir ) ) );			// Clear Any Delayed Function Calls			clearInterval ( tme );			// Scroll the List Again after a Delay			if ( rec ) tme = setTimeout ( do_scroll, 100, dir );		}				// Display the Appropriate List Options		private function do_options ( min:int = 0 ) : void {			// Save Local References to Global Variables			var _rws:int = rws, _len:int = len, _flt:Array = flt, _opt:Vector.<TextField> = opt;			// Save a Refernece to the Starting Index			var i:int = min < 0 ? 0 : min >= _len - rws ? _len - _rws : min > 0 ? min - 1 : 0;			// Display/Hide the Up Scroll Arrow Button			arw [ 0 ].visible = min > 0;			// Display/Hide the Down Scroll Arrow Button			arw [ 1 ].visible = min + _rws < _len - 1;			// Loop through the List Option TextFields			for ( var n:int = _opt.length, m:int = 0; n--; ) {				// Save a Refernece to the Current List Option TextField				var fld:TextField = _opt [ m++ ];				// Display the Appropriate List Option Text				fld.text = _flt [ i++ ] || '';				// Display/Hide the List Option TextField				fld.visible = m <= _rws;			}		}				// Calculate Math.min But Faster		private function min ( a:Number, b:Number ) : Number { return a < b ? a : b }				// Calculate Math.max But Faster		private function max ( a:Number, b:Number ) : Number { return a > b ? a : b }	}}
>>>>>>> 3b35c7c759795703c8f64e85f067bdd4223cd508
