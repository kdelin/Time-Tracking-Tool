 // Define the Packagepackage classes.view.piechart {		// Import Necessary Classes	import flash.filters.DropShadowFilter;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.Rectangle;	import flash.events.MouseEvent;		import flash.events.Event;		import flash.display.MovieClip;	import flash.display.Graphics;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.text.TextField;			import classes.view.piechart.PieChartHandle;	import classes.view.piechart.PieChartEvent;		// Define the Class	public final class PieChart extends Sprite {				// Create Rectangle for dragging bars				var rectangle:Rectangle = new Rectangle(0,0,0,0);		// Set up angle increment		var cnv:Number = 1 / ( 180 / Math.PI );		var pos:int = 0;		// Create a Variable for Incrementing the Angle		var ang:Number = -90;		// Create Var for circle MovieClip		var tar:MovieClip;		var tar2:MovieClip;		// Save a Reference to the Pie Radius		var rad:Number;		// Save a Reference to the Graphics Object		var pen:Graphics;		var nPen:Graphics;		// Create array for values				var vls:Array = [];				//var vls:Vector.<Number> = new Vector.<Number>;		// Create array for handle positions		var hpos:Array = [0, 0, 0];		// Create array for Colors		var col:Array = [ 0xCCCCCC, 0xAAAAAA, 0x888888, 0xd2d2d2, 0xa9a9a9, 0x7c7c7c, 0x4f4f4f ];		// Create a reference to the object		var nobj:Object;				var newP:Number;								// Instantiate the Class		public function PieChart(obj:Object): void {						// Create DropShadowFilter Object			filters = filters.concat ( new DropShadowFilter ( 2, 89.9993809572637, 0, 1, 6, 6, 0.5, 3, false, false, false ) );			// Save reference to object			nobj = obj; 			// Save Reference to values from object			vls = obj.values;					// Save Reference to circle MovieClip			tar = pie_mc;			// Position MovieClip			mc_chart.x = obj.x; mc_chart.y = obj.y;			// Save a Reference to the Pie Radius			rad = tar.width * .5;			// Save a Reference to the Graphics Object			pen = mc_chart.graphics;			nPen = tar.graphics;			// Remove Child Shape			tar.removeChild ( tar.getChildAt ( 0 ) );			// Maintain Scale			tar.scaleX = tar.scaleY = 1;						// Draw Graph			drawPieChart();			// Create the handles for dragging Graph			createHandles();			trace(vls);						//mc_chart.alpha = 0;		}				private function createHandles():void {						for ( var x:int = 0; x < vls.length; x++ ) {								pos += (Math.round ( vls [ x ] * 359 ));				hpos[x] = pos;												var handle:PieChartHandle;				handle = new PieChartHandle(rad, rad);				handle.x = handle.radiusX + (nobj.x*.5)-15;				handle.y = handle.radiusY + (nobj.y*.5)-26;				handle.value = pos;				handle.name = "handle" + x;								handle.addEventListener(MouseEvent.MOUSE_UP, onMouseOff);				handle.addEventListener(Event.CHANGE, changeHandler);				mc_handle.addChild(handle);							}					}				private function removeHandles():void {			var c:int = mc_handle.numChildren;						for ( var x:int = c; x--; ) { mc_handle.removeChildAt(x); };		}				private function onMouseOff(e:Event):void {			//removeHandles();			//createHandles();		}		private function changeHandler(e:Event):void {						var np:Number = e.target.value;						var n:String = e.target.name;			n = n.substr(6, 1);			var h:Number = Number(n);						var r:Number;					// original percentage			var s:Number;					// new percentage			var t:Number; 					// difference									// if first handle in the array			if ( h == 0 ) {				if ( np > hpos[0] && np < hpos[1] ) {					// original percentage					r = hpos[0]/359;					// new percentage					s = np/359;					// Update %					vls[0] = (hpos[0]-(ang+90))/359;					// get the difference					t = s-r;					// add it to the neighboring field					vls[1] = vls[1]-t;							// update position					hpos[0] = np;				} else if ( np < hpos[0] && np > 0 ) {										// original percentage					r = hpos[0]/359;					// new percentage					s = np/359;					// get the difference					t = r-s;					// correct for flip					if ( t > .5) { t = .01 };					// Update %					vls[0] = vls[0]-t;					// add it to the neighboring field					vls[1] += t;					// update position					hpos[0] = np;				} else if ( np > hpos[vls.length-1] && hpos[0] < hpos[1] ) {					// correct for flip					hpos[0] = (np+.1);					// original percentage					r = hpos[0]/359;					// new percentage					s = np/359;					// get the difference					t = r-s;					// update %					vls[0] = vls[0] - t;					// add to neighboring field					vls[1] = vls[1] + t;					// update position					hpos[0] = np;									}  else if ( np > 0 && hpos[0] < hpos[vls.length-1] ) {					// correct for flip					hpos[0] = (np+.1);					// original percentage					r = hpos[0]/359;					// new percentage					s = np/359;					// get the difference					t = r-s;					// Update %					vls[0] = vls[0] + t;					// add to neighboring field					vls[1] = vls[1] - t;					// update position					hpos[0] = np;									} else if ( np > hpos[vls.length-1] && np < hpos[0] ) {					//original percentage					r = hpos[0]/359;					// new percentage					s = np/359;					// get the difference					t = r-s;					// Update %					vls[0] = vls[0] - t;					// add to neighboring field					vls[1] = vls[1] + t;					// update position					hpos[0] = np;									}  else if ( np > hpos[vls.length-1] && np > hpos[0] ) {					// original percentage					r = hpos[0]/359;					// new percentage					s = np/359;					// get the difference					t = s-r;					// Update %					vls[0] = vls[0] + t;					// add to neighboring field					vls[1] = vls[1] - t;					// update position					hpos[0] = np;									}						// if last handle in the array			} else if ( h == vls.length-1 ) {				// original percentage				r = hpos[h]/359;											if ( np < hpos[h-1] ) {					// Update Starting angle					ang = -90+np;										// new percentage					s = (np+359)/359;									// get the difference					t = s-r;					// Update %					vls[h] = vls[h] + t;					// add it to the neighboring field					vls[0] = vls[0]-t;					// update position					hpos[h] = np+359;				} else if ( np > hpos[0] ) {					// Update Starting angle					ang = -90-(359-np);										// new percentage					s = np/359;					// get the difference					t = r-s;						// Update %					vls[h] = vls[h] - t;					// add it to the neighboring field					vls[0] = vls[0]+t;					// update position					hpos[h] = np;				}			// deal with last handle flip			} else if ( h == vls.length-2 && np < hpos[0] && hpos[h] > hpos[0] ) {				// update old location				hpos[h] = np;				// update new location				np += .1;									// original percentage				r = hpos[h]/359;				// new percentage				s = np/359;				// get the difference				t = s-r;				// Update %				vls[h] = vls[h] - t;				// add to neighboring field				vls[h-1] = vls[h-1] + t;				// update position				hpos[h] = np;												} else if ( h == vls.length-2 && np > hpos[h-1] && hpos[h] < hpos[0] ) {				// update old location				hpos[h] = (np+.1);				// original percentage				r = hpos[h]/359;				// new percentage				s = np/359;				// get the difference				t = r-s;				// Update %				vls[h] = vls[h] + t;				// add to neighboring field				vls[h-1] = vls[h-1] - t;				// update position				hpos[h] = np;												}  else if ( h == vls.length-2 && np < hpos[h] && np > hpos[h-1] ) {				// original percentage				r = hpos[h]/359;				// new percentage				s = np/359;				// Update %				vls[h] = s-hpos[h-1]/359;				// get the difference				t = s-r;				// add it to the neighboring field				vls[h+1] = vls[h+1]-t;				// update position				hpos[h] = np;			} else if ( h == vls.length-2 && np > hpos[h] && np < 359 ) {				// original percentage				r = hpos[h]/359;				// new percentage				s = np/359;				// get the difference				t = s-r;					// Update %				vls[h] = vls[h]+t;				// add it to the neighboring field				vls[h+1] = vls[h+1]-t;				// update position								trace(vls[h]+ " " + t);				hpos[h] = np;			} else if ( h == vls.length-2 && np > 0 && np < hpos[h] ) {				// original percentage				r = hpos[h]/359;				// new percentage				s = np/359;				// get the difference				t = r-s;				vls[h] = vls[h]-t;				// add it to the neighboring field				vls[h+1] = vls[h+1]+t;				// update position				hpos[h] = np;						// all other handles			} else {				// original percentage				r = hpos[h]/359;				// new percentage				s = np/359;											if ( np < hpos[h] ) {					// get the difference					t = r-s;					// Update %					vls[h] = vls[h]-t;					// add it to the neighboring field					vls[h+1] = vls[h+1]+t;					// update position					hpos[h] = np;				} else if ( np > hpos[h] ) {					// get the difference					t = s-r;						// Update %					vls[h] = vls[h]+t;					// add it to the neighboring field					vls[h+1] = vls[h+1]-t;					// update position					hpos[h] = np;				}							}						//trace(vls + "\n");			// dispatchEvent( new PieChartEvent(PieChartEvent.PIE_CHART_STOPDRAG, true, false, "true"));						pen.clear();			drawPieChart();		}								private function drawPieChart():void {						// Store starting angle			var tang:Number = ang;			// Convert Degrees to Radians			var rdn:Number = ang * cnv;			// Calculate the X Position			var xps:Number = rad * Math.cos ( rdn );			// Calculate the Y Position			var yps:Number = rad * Math.sin ( rdn );						// Set the Line Style			pen.lineStyle ( 3, 0xFFFFFF );			// Draw a Line from the Center of the Pie			pen.lineTo ( xps, yps );									for ( var i:int = 0; i < vls.length; i++ ) {				// Save a Refernece to the Degree				var deg:int = 1 + Math.round ( vls [ i ] * 359 );								// Set the Fill Color				pen.beginFill ( col [ i ] );				// Move to the Outer Edge				pen.moveTo ( xps || rad, yps );				// Loop Through Each Interim Degree				for ( var n:int = deg; n--; ) {					// Convert Degrees to Radians					rdn = ang++ * cnv;					// Calculate the X Position					xps = rad * Math.cos ( rdn );					// Calculate the Y Position					yps = rad * Math.sin ( rdn );					// Draw a Line to the Appropriate Coordinates					pen.lineTo ( xps, yps );									}								// Draw a Line to the Center of the Pie								pen.lineTo ( 0, 0 );			}						// Return starting angle to original location			ang = tang;								}									}}